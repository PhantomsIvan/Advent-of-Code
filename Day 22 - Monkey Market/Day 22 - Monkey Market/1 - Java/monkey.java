/* 
Youa are trading information for bananas the monkeys offer their price which is paid in bananas

 Question 1
 Asks to produce a "Step function"
 A "psuedo random number" is generated by finding first mixing the number and then pruning it in 3 difference ways 

 Each time we find the Bitwise XOR method see the ^ symbol to scramble the result 

 Note that Bitwise XOR might as well have a parenthesis over the expression next to it

 We implement this 2000 times to get the sum


 Question 2
 We are asked essentially to find a sequence of 4 numbers that ends in the highest number e the final number of bananas they buyer has

 The secret for instance 123 has a value of 3 as the ones place meaning the monkey is willing to pay 3 bananas

 If you put it on the step method the first number is 15887950 and their price is 0 meaning they want to pay 0 bananas

 Goal --- We want the buyer to spend most amount to get the most bananas from the monkeys

 Note -- since it's the one's there are 0 to 9 digits and chance can occur |+9| |-9| and 0 ways  18+1 = 19 

 For each line/buyer in the input.txt file
 1 we set up a list and generate the 2000 prices for each buyer


 2  Hash Set - we cycle through a sequence of 4 numbers at size()-4 we keep in an a Hash set and record e the final amount of bananas each has set
            - we skip sequences we've seen for from that buyer before
    Hash Map - for each buyer if we see a sequence we update and sum up the total in the dictionary for that sequence
            - we then find which sequence ends up with the most amount of bananas for the buyer

 */

import java.io.BufferedReader; //reads line by line
import java.io.FileReader; //opens the file input.txt file
import java.io.IOException; //Java won't run unless we throw the IOexceptions
import java.util.ArrayList; // we store the buyers
import java.util.Arrays; // part of we store the sequence
import java.util.HashMap; //to contain the dictionary of keys related to the sequence see seqtototal, contains the sequence and total
import java.util.HashSet; //keeps track of sequences we've seen 
import java.util.List;
import java.util.Map;
import java.util.Set; //contains the set of intergers or sequences in the seen pile

public class Monkey {

    // " ^ " is a common bitwise XOR check XOR is a bitwise operator, and it stands for "exclusive or." It performs logical operation.
    /// -- If input bits are the same, then the output will be false(0) else true(1).
    //The numbers were given and not necessarily calculated by me   
    private static long step(long num) {  
        num = (num ^ (num * 64)) % 16777216; // note by default 64 and 16777216 treated as int but 64L and 16777216L turns it into a long
        num = (num ^ (num / 32)) % 16777216;  
        num = (num ^ (num * 2048)) % 16777216;
        return num;
    }

    private static void partOne() throws IOException {
        long total = 0;
        BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
        String line;
        while ((line = reader.readLine()) != null) {
            long num = Long.parseLong(line.trim());  // Changed to Long.parseLong
            for (int i = 0; i < 2000; i++) {
                num = step(num);
            }
            total += num;
        }
        reader.close();
        System.out.println(total);
    }

   private static void partTwo() throws IOException {
    Map<List<Integer>, Long> seqToTotal = new HashMap<>();
    BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
    String line;
    
    while ((line = reader.readLine()) != null) {
        long num = Long.parseLong(line.trim());  
        List<Integer> buyer = new ArrayList<>(); //establishing the secret number for each buyer for each transaction
        buyer.add((int)(num % 10));  //the one places is explained to be the initial level of banana the monkey is willing to pay
       
       //we use the step function to to create the prices for the buyer
       //note that %10 is the ones place value and is the banana the monkey is willing to pay 
       //we take each price
        for (int i = 0; i < 2000; i++) {
            num = step(num);
            buyer.add((int)(num % 10));
        }
        

        //we then take the list of banana amounts the buyer is willing to pay
        // and track final amount e associated with the sequence
        Set<List<Integer>> seen = new HashSet<>();
        for (int i = 0; i < buyer.size() - 4; i++) {
            // Get 5 consecutive numbers
            //size()-4 to ensure that we don't start a range we can't end 
            //if there are 5 numbers we can't a sequence ast the 3rd element "3 4 5"
            //if there are 6 numbers we can't start at the 2nd element either because "2 3 4 5" 6 is trailing
            int a = buyer.get(i);
            int b = buyer.get(i + 1);
            int c = buyer.get(i + 2);
            int d = buyer.get(i + 3);
            int e = buyer.get(i + 4);
            
            // Calculate differences
            //as show in the the table in part two
            //we create a sequence here and characterise a key with a matching e final amount of banananas 
            List<Integer> seq = Arrays.asList(b - a, c - b, d - c, e - d);
            
            if (seen.contains(seq)) { //we skip sequences we've seen before, remember e is the final number of bananas so if seq is the same e is the same
                continue;
            }
            seen.add(seq);
            
            seqToTotal.merge(seq, (long)e, Long::sum);  // "long::sum" same as (oldValue, newValue) -> oldValue + newValue
        }
    }
    reader.close();

    long maxValue = 0;
    for (Long value : seqToTotal.values()) {
        if (value > maxValue) {
            maxValue = value;
        }
    }
    System.out.println(maxValue);
        
        //also long maxValue = seqToTotal.values().stream().mapToLong(Long::longValue).max().orElse(0);
        // .mapToLong(Long::longValue)  converts values into a primitive long taking the long value from the object containing the long
        //find the max value
        //default and returns to 0 when max number is empty
     
    }

    public static void main(String[] args) throws IOException {
        partOne();
        partTwo();
    }
}